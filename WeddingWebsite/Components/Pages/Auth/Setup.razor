@page "/Account/Setup"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Identity.EntityFrameworkCore
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.EntityFrameworkCore
@using WeddingWebsite.Components.Sections
@using WeddingWebsite.Core
@using WeddingWebsite.Data

@inject UserManager<Account> UserManager
@inject IUserStore<Account> UserStore
@inject ILogger<Register> Logger
@inject SignInManager<Account> SignInManager
@inject IdentityRedirectManager RedirectManager
@inject RoleManager<IdentityRole> RoleManager

@attribute [AllowAnonymous]

<Section>
    
    <h1>Account Setup</h1>

    <p>Please create an account for yourself. This account will not only be given admin access, but will be the only account to be marked as "owner". The only difference is that owners have the ability to promote/demote other admins.</p>

    <div class="row">
        <div class="col-md-4">
            <p>@Message</p>
            <EditForm Model="Input" asp-route-returnUrl="/" method="post" OnValidSubmit="RegisterUser" FormName="register">
                <DataAnnotationsValidator />
                <h2>Create an admin account</h2>
                <p>Please choose a secure password!</p>
                <hr style="margin-bottom: 5px" />
                <ValidationSummary class="text-danger" role="alert" />
                <div class="form-floating">
                    <label for="email">Email</label>
                    <MudSpacer/>
                    <InputText @bind-Value="Input.Email" class="form-control" autocomplete="username" aria-required="true" placeholder="name@example.com" id="email"/>
                    <ValidationMessage For="() => Input.Email" class="text-danger" />
                </div>
                @* <div class="form-floating"> *@
                @*     <label for="username">Username (Generally first name and surname, but up to you. May be used in the user interface. No need to be unique.)</label> *@
                @*     <MudSpacer/> *@
                @*     <InputText @bind-Value="Input.UserName" class="form-control" aria-required="true" placeholder="John Smith" id="username"/> *@
                @*     <ValidationMessage For="() => Input.UserName" class="text-danger" /> *@
                @* </div> *@
                <div class="form-floating">
                    <label for="password">Password</label>
                    <MudSpacer/>
                    <InputText type="password" @bind-Value="Input.Password" class="form-control" autocomplete="new-password" aria-required="true" placeholder="password" id="password" />
                    <ValidationMessage For="() => Input.Password" class="text-danger" />
                </div>
                <div class="form-floating mb-3">
                    <label for="confirm-password">Confirm Password</label>
                    <MudSpacer/>
                    <InputText type="password" @bind-Value="Input.ConfirmPassword" class="form-control" autocomplete="new-password" aria-required="true" placeholder="password" id="confirm-password" />
                    <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger" />
                </div>
                <button type="submit">Register</button>
            </EditForm>
        </div>
    </div>
    
</Section>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    protected override async Task OnInitializedAsync()
    {
        await RedirectIfUsersExist();
    }
    
    private async Task<bool> RedirectIfUsersExist()
    {
        var anyUsers = await UserManager.Users.AnyAsync();
        if (anyUsers)
        {
            RedirectManager.RedirectTo("/");
            return true;
        }

        return false;
    }

    public async Task RegisterUser(EditContext editContext)
    {
        // Check if there are any users already - if so, don't allow setup
        if (await RedirectIfUsersExist()) return;
        
        // Create the admin role if it doesn't exist
        if (!await RoleManager.RoleExistsAsync("Admin"))
        {
            var roleResult = await RoleManager.CreateAsync(new IdentityRole("Admin"));
            if (!roleResult.Succeeded)
            {
                identityErrors = roleResult.Errors;
                return;
            }
        }
        
        // Create the owner role if it doesn't exist
        if (!await RoleManager.RoleExistsAsync("Owner"))
        {
            var roleResult = await RoleManager.CreateAsync(new IdentityRole("Owner"));
            if (!roleResult.Succeeded)
            {
                identityErrors = roleResult.Errors;
                return;
            }
        }
        
        Logger.LogInformation("Registering the owner.");
    
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        var emailStore = GetEmailStore();
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);
        var result = await UserManager.CreateAsync(user, Input.Password);
        await UserManager.AddToRoleAsync(user, "Owner");
        await UserManager.AddToRoleAsync(user, "Admin");

        if (!result.Succeeded)
        {
            identityErrors = result.Errors;
            return;
        }

        Logger.LogInformation("User created a new account with password.");

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

        await SignInManager.SignInAsync(user, isPersistent: false);
        RedirectManager.RedirectTo("/");
    }

    private Account CreateUser()
    {
        try
        {
            return Activator.CreateInstance<Account>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(Account)}'. " +
                $"Ensure that '{nameof(Account)}' is not an abstract class and has a parameterless constructor.");
        }
    }

    private IUserEmailStore<Account> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }
        return (IUserEmailStore<Account>)UserStore;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "Email")]
        public string Email { get; set; } = "";
        
        // [Required]
        // [Display(Name = "Username")]
        // public string UserName { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "Password")]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }
}
